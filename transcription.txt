 Сейчас мы рассмотрим с вами еще один тип данных у Python, а именно мы поговорим о наборах, set. Этот тип является на мой взгляд очень мощным инструментом Python, и он очень легко позволяет выполнять различные действия с разными наборами данных. Например, можно очень легко найти пересечение двух наборов элементов, либо же можно объединить два набора элементов. Причем в результате вы получаете только уникальные элементы. Итак, давайте начнем обсуждение того, что такое наборы, как они выглядят и как с ними работают. Набор – это неупорядочная последовательность элементов. Мы говорили с вами о списках, о кратежах, которые являются упорядочеными последовательностями, также мы говорили с вами о словарях, которые являются неупорядочными последовательностями. Так вот, набор – это также неупорядоченная последовательность элементов. То есть порядок элементов в наборах роли не играет. И легко предположить, что в наборах у элементов нет индекса. Набор содержит только уникальные элементы, это еще одна важная характеристика набора. Только уникальнее. И если вы в набор добавляете еще один элемент, который в этом наборе уже есть, то такой элемент добавлен не будет. Но изменять наборы можно. И можно добавлять новые элементы в набор, а можно удалять элементы из набора. В наборах обычно сохраняют однотипные данные, например набор стр, либо набор целых чисел, либо же набор чисел с плавающей точкой. Обычно однотипные данные в наборах. Давайте посмотрим на структуру и синтексис наборов. Здесь вы видите некоторые переменные, такие как MyFruits, Post, IDEs и UserInputs. В принципе, мы уже видели с вами ранее похожие наборы данных, но мы говорили о них в контексте списков и картежей. Здесь же вы видите, что элементы находятся между фигурных скобок, видите, открывающей фигурную скобку и закрывающей фигурную скобку. Вы скажете, о словариже создаются тоже с помощью фигурных скобок. Но отличие набора и словарей в том, что в наборах у нас просто элементы, как в списках. А в словарях у нас пары, ключ, значения. И потому, исходя из того, как именно вы указываете элементы в наборе, либо в словаре, Пайтон понимает, где набор, а где словарь. То есть это для Пайтон набор. Исследовательно, Пайтон создаст объект, который наследует все методы из класса Set набор. В следующем примере вы также видите набор. Набор из целых чисел. Также можно добавлять набор элементов разных типов, но зачастую так не делают. И как я уже отметил, в наборах содержатся элементы одного и того же типа. При выводе значения типа Set в Этерминал вы увидите вот такую структуру данных. В фигурных скобках вы увидите элементы, разделенные за пятыми. Но при этом отмечу еще раз, что порядок следования в наборах не имеет значения. И у этих элементов нет своих индексов. Также при вызове встроенной функции Type вы увидите класс Set, потому что все наборы являются экземплярами класса Set. И, следовательно, наследуют все методы, определенные на уровне класса Set. Теперь посмотрим, например, из которого очень хорошо видна особенность набора. Смотрите, в данном примере мы создаем набор, используя фигурные скобки, и в этом наборе некоторые элементы повторяются. Например, вот этот и вот этот элемент одинаковы, и также одинаковы эти элементы. Так вот в таком случае при создании набора никакой ошибки не будет. Но при выводе набора в терминал, например, либо при его другом использовании вы увидите только уникальные элементы. Дубликаты автоматически будут удалены. Смотрите, здесь осталось три элемента в этом наборе. В чем же преимущество такого поведения набора? А преимущество в том, что эту структуру данных вы можете легко использовать для того, чтобы быстро найти уникальное значение среди большой последовательности неуникальных значений. Допустим, у вас есть список, в котором содержатся ID-комментариев. И ваша задача сделать так, чтобы вы нашли только уникальное значение. То есть вы можете перебрать список, сделать итерацию по списку и создать на основании этого списка новый список, добавляя у него только уникальное значение. А можно список просто конвертировать в набор. И тогда все неуникальные значения будут удалены и останутся только уникальны. И далее вы уже можете провести, например, итерацию уже по набору и выполнить определенные действия с каждым из комментариев. То есть, дубликаты удаляются даже если вы создавая набор, добавляете дубликаты. Далее, если сравнивать два таких набора, MyFruits и OtherFruits, то для Python это два одинаковых набора. Потому что, во-первых, у них одинаковое количество элементов и, во-вторых, элементы те же. Apple есть и там и там, Banana есть и там, и Lime есть и там и там. Это происходит из-за того, что в наборах порядок не важен. И снова-таки, используя эту характеристику, вы легко можете сравнивать две последовательности данных. И просто используя оператор сравнения, вы можете понять, одинаковые наборы данных или нет. В данном примере, при использовании оператора сравнения для объекта MyFruits и OtherFruits, мы получим true, потому что это одинаковые наборы в Python. Длину набора можно найти используя ту же встроенную функцию LAN, что и для других типов данных. И, во-первых примере, длина набора 3, в нем 3 элемента, во-втором наборе 4 элемента. То есть та же функция LAN используется и для наборов. Но при этом, как я уже ранее отметил, индекса у элементов нет. И если вы попытаетесь использовать квадратный скобки вот таким образом, вы получите ошибку. Type error setObjectIsNotSubscriptable. Это означает, что получить значение по индексу в наборе нельзя, а это из-за того, что наборы не имеют строго и последовательности элементов. Это неупорядоченная последовательность элементов.